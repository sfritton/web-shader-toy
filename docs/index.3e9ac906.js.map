{"mappings":"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","sources":["src/scripts/index.ts","src/scripts/FlameShader.ts","src/scripts/Shader.ts","src/scripts/util.ts"],"sourcesContent":["import { FlameShader } from './FlameShader';\n\nconst canvas = document.querySelector<HTMLCanvasElement>('canvas');\n\nnew FlameShader(canvas);\n","import { Shader } from './Shader';\nimport { pointOnCircle, randomVector } from './util';\n\nconst WORKGROUP_SIZE = 64;\nconst PARTICLE_SIZE = 0.1;\nconst PARTICLE_COUNT = WORKGROUP_SIZE * 256;\nconst SPEED = 0.004;\nconst GRAVITY = 0.005;\nconst PARTICLE_INTERVAL = 5;\nconst DECAY_RATE = 0.004;\nconst ORIGIN_RADIUS = 0.2;\nconst ORIGIN_Y = -0.4;\n\nconst TRIANGLE_COUNT = 32;\nconst THETA = (2 * Math.PI) / TRIANGLE_COUNT;\nconst VERTICES = new Float32Array(TRIANGLE_COUNT * 6); // 6 for the x,y coordinates of the three points on the triangle\n\nfor (let triangleIndex = 0; triangleIndex < TRIANGLE_COUNT; triangleIndex++) {\n  const i = triangleIndex * 6;\n  const point1 = pointOnCircle(1, triangleIndex * THETA);\n  const point2 = pointOnCircle(1, (triangleIndex + 1) * THETA);\n\n  VERTICES[i] = 0;\n  VERTICES[i + 1] = 0;\n\n  VERTICES[i + 2] = point1.x;\n  VERTICES[i + 3] = point1.y;\n\n  VERTICES[i + 4] = point2.x;\n  VERTICES[i + 5] = point2.y;\n}\n\nexport class FlameShader extends Shader {\n  vertexBuffer!: GPUBuffer;\n  renderPipeline!: GPURenderPipeline;\n  computePipeline!: GPUComputePipeline;\n  bindGroups!: GPUBindGroup[];\n  frameLength = 0;\n\n  setup() {\n    const particleCounter = document.getElementById('particle-count');\n    if (particleCounter) {\n      particleCounter.textContent = `${Math.floor(PARTICLE_COUNT / 1000)}k`;\n    }\n    /*\n    ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n    │ PARTICLE SHAPE                  │\n    ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n    */\n    this.vertexBuffer = this.device.createBuffer({\n      label: 'Particle Vertices',\n      size: VERTICES.byteLength,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    });\n\n    this.device.queue.writeBuffer(this.vertexBuffer, 0, VERTICES);\n\n    const vertexBufferLayout: GPUVertexBufferLayout = {\n      arrayStride: 8,\n      attributes: [\n        {\n          format: 'float32x2',\n          offset: 0,\n          shaderLocation: 0, // Position, see vertex shader\n        },\n      ],\n    };\n\n    /*\n    ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n    │ PARTICLE DATA                   │\n    ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n    */\n\n    /**\n     * Particle state, stored as [\n     *   position.x,\n     *   position.y,\n     *   velocity.x,\n     *   velocity.y,\n     *   lifespan\n     * ]\n     *\n     */\n    const particleStates = new Float32Array(PARTICLE_COUNT * PARTICLE_INTERVAL);\n\n    for (let i = 0; i < particleStates.length; i += PARTICLE_INTERVAL) {\n      const position = randomVector(ORIGIN_RADIUS);\n      const velocity = randomVector(ORIGIN_RADIUS);\n\n      particleStates[i] = position.x;\n      particleStates[i + 1] = position.y + ORIGIN_Y;\n      particleStates[i + 2] = velocity.x;\n      particleStates[i + 3] = velocity.y;\n      particleStates[i + 4] = Math.random();\n    }\n\n    const particleStatesStorage = [\n      this.device.createBuffer({\n        label: 'Particle State A',\n        size: particleStates.byteLength,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      }),\n      this.device.createBuffer({\n        label: 'Particle State B',\n        size: particleStates.byteLength,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      }),\n    ];\n\n    this.device.queue.writeBuffer(particleStatesStorage[0], 0, particleStates);\n\n    const initialStatesStorage = this.device.createBuffer({\n      label: 'Initial Particle State',\n      size: particleStates.byteLength,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n\n    this.device.queue.writeBuffer(initialStatesStorage, 0, particleStates);\n\n    /*\n    ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n    │ BIND GROUPS & LAYOUTS           │\n    ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n    */\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'Particle Bind Group Layout',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' }, // Particle state input buffer\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' }, // Particle state output buffer\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' }, // Uniform buffer\n        },\n      ],\n    });\n\n    this.bindGroups = [\n      this.device.createBindGroup({\n        label: 'Particle renderer bind group A',\n        layout: bindGroupLayout,\n        entries: [\n          {\n            binding: 0,\n            resource: { buffer: particleStatesStorage[0] },\n          },\n          {\n            binding: 1,\n            resource: { buffer: particleStatesStorage[1] },\n          },\n          {\n            binding: 2,\n            resource: { buffer: initialStatesStorage },\n          },\n        ],\n      }),\n      this.device.createBindGroup({\n        label: 'Particle renderer bind group B',\n        layout: bindGroupLayout,\n        entries: [\n          {\n            binding: 0,\n            resource: { buffer: particleStatesStorage[1] },\n          },\n          {\n            binding: 1,\n            resource: { buffer: particleStatesStorage[0] },\n          },\n          {\n            binding: 2,\n            resource: { buffer: initialStatesStorage },\n          },\n        ],\n      }),\n    ];\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      label: 'Particle pipeline layout',\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    /*\n    ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n    │ COMPUTE PIPELINE                │\n    ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n    */\n    const computeShaderModule = this.device.createShaderModule({\n      label: 'Flame compute shader',\n      code: /* wgsl */ `\n        @group(0) @binding(0) var<storage> particleStatesIn: array<f32>;\n        @group(0) @binding(1) var<storage, read_write> particleStatesOut: array<f32>;\n        @group(0) @binding(2) var<storage> initialStates: array<f32>;\n\n        @compute\n        @workgroup_size(${WORKGROUP_SIZE})\n        fn computeMain(@builtin(global_invocation_id) index: vec3u) {\n          let i = index.x * ${PARTICLE_INTERVAL};\n          let positionIn = vec2f(particleStatesIn[i], particleStatesIn[i+1]);\n          let velocityIn = vec2f(particleStatesIn[i+2], particleStatesIn[i+3]);\n          let lifespan = particleStatesIn[i+4] - ${DECAY_RATE};\n\n          let positionOut = positionIn + velocityIn * ${SPEED};\n          let velocityOut = vec2f(velocityIn.x, velocityIn.y + ${GRAVITY});\n\n          // reset the particle\n          if (lifespan < 0) {\n            particleStatesOut[i] = initialStates[i];\n            particleStatesOut[i+1] = initialStates[i+1];\n            particleStatesOut[i+2] = initialStates[i+2];\n            particleStatesOut[i+3] = initialStates[i+3];\n            particleStatesOut[i+4] = 1;\n          } else {\n            particleStatesOut[i] = positionOut.x;\n            particleStatesOut[i+1] = positionOut.y;\n            particleStatesOut[i+2] = velocityOut.x;\n            particleStatesOut[i+3] = velocityOut.y;\n            particleStatesOut[i+4] = lifespan;\n          }\n        }\n      `,\n    });\n\n    this.computePipeline = this.device.createComputePipeline({\n      label: 'Flame compute pipeline',\n      layout: pipelineLayout,\n      compute: {\n        module: computeShaderModule,\n        entryPoint: 'computeMain',\n      },\n    });\n\n    /*\n    ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n    │ RENDER PIPELINE                 │\n    ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n    */\n    const renderShaderModule = this.device.createShaderModule({\n      label: 'Flame render shader',\n      code: /* wgsl */ `\n        struct VertexInput {\n          @location(0) pos: vec2f,\n          @builtin(instance_index) instance: u32,\n        };\n\n        struct VertexOutput {\n          @builtin(position) pos: vec4f,\n          @location(0) lifespan: f32,\n          @location(1) alpha: f32,\n        };\n\n        @group(0) @binding(0) var<storage> particleStates: array<f32>;\n\n        // Returns a y value between 0 and 1\n        fn lerp(x: f32, x1: f32, x2: f32, y1: f32, y2: f32) -> f32 {\n          return y1 + (x - x1) * (y2 - y1) / (x2 - x1);\n        }\n\n        fn particleScale(lifespan: f32) -> f32 {\n          let fullSizeBegin = 0.85;\n          let fullSizeEnd = 0.8;\n\n          if (lifespan > fullSizeBegin) {\n            return lerp(lifespan, 1, fullSizeBegin, 0, 1);\n          } else if (lifespan > fullSizeEnd) {\n            return 1;\n          } else {\n            return lerp(lifespan, fullSizeEnd, 0, 1, 0);\n          }\n        }\n        \n        @vertex\n        fn vertexMain(input: VertexInput) -> VertexOutput {\n          let i = input.instance * ${PARTICLE_INTERVAL};\n          let position = vec2f(particleStates[i], particleStates[i+1]);\n          let lifespan = particleStates[i+4];\n          let scale = particleScale(lifespan);\n          let pos = (input.pos * ${PARTICLE_SIZE} * scale) + position;\n\n          var output: VertexOutput;\n          output.pos = vec4f(pos, 0, 1);\n          output.lifespan = lifespan;\n          if (input.pos.x == 0 && input.pos.y == 0) {\n            output.alpha = scale;\n          } else {\n            output.alpha = 0;\n          }\n          return output;\n        }\n\n        @fragment\n        fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n          return vec4f(2, input.lifespan * 1.5, input.lifespan * 2 - 0.75, 1) * input.alpha; // rgba\n        }\n      `,\n    });\n\n    this.renderPipeline = this.device.createRenderPipeline({\n      label: 'Flame render pipeline',\n      layout: pipelineLayout,\n      vertex: {\n        module: renderShaderModule,\n        entryPoint: 'vertexMain',\n        buffers: [vertexBufferLayout],\n      },\n      fragment: {\n        module: renderShaderModule,\n        entryPoint: 'fragmentMain',\n        targets: [\n          {\n            format: this.canvasFormat,\n            blend: {\n              color: {\n                srcFactor: 'one',\n                dstFactor: 'one-minus-src-alpha',\n              },\n              alpha: {\n                srcFactor: 'one',\n                dstFactor: 'one-minus-src-alpha',\n              },\n            },\n          },\n        ],\n      },\n    });\n  }\n\n  update(deltaT?: number) {\n    const encoder = this.device.createCommandEncoder();\n\n    // Start a compute pass\n    const computePass = encoder.beginComputePass();\n\n    computePass.setPipeline(this.computePipeline);\n    computePass.setBindGroup(0, this.bindGroups[this.step % 2]);\n\n    const workgroupCount = Math.ceil(PARTICLE_COUNT / WORKGROUP_SIZE);\n    computePass.dispatchWorkgroups(workgroupCount, workgroupCount);\n\n    computePass.end();\n\n    this.step++;\n\n    // Start a render pass\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: this.context.getCurrentTexture().createView(),\n          loadOp: 'clear',\n          clearValue: { r: 0.2, g: 0.2, b: 0.3, a: 1 },\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    pass.setPipeline(this.renderPipeline);\n    pass.setVertexBuffer(0, this.vertexBuffer);\n    pass.setBindGroup(0, this.bindGroups[this.step % 2]);\n    pass.draw(VERTICES.length / 2, PARTICLE_COUNT);\n\n    pass.end();\n\n    // Finish the command buffer and immediately submit it.\n    this.device.queue.submit([encoder.finish()]);\n  }\n}\n","export abstract class Shader {\n  private _context: GPUCanvasContext | null | undefined = undefined;\n  device!: GPUDevice;\n  canvasFormat!: GPUTextureFormat;\n  /** Milliseconds between frames. Set to 0 for maximum FPS. */\n  frameLength: number = 200;\n  prevMS: number | undefined = undefined;\n  avgDeltaT = 0;\n  // TODO: handle incrementation in Shader class by separating compute and render functions\n  /** The current step of the animation, increment it in your update function. */\n  step = 0;\n\n  constructor(canvas: HTMLCanvasElement | null) {\n    this.init(canvas).then(() => {\n      this.setup();\n      if (this.frameLength === 0) {\n        const step = (currMS: number) => {\n          if (this.prevMS === undefined) this.prevMS = currMS;\n          const deltaT = currMS - this.prevMS;\n          this.avgDeltaT = (this.avgDeltaT * this.step + deltaT) / (this.step + 1);\n          this.prevMS = currMS;\n\n          requestAnimationFrame(step);\n          this.update(deltaT);\n        };\n\n        requestAnimationFrame(step);\n      } else {\n        setInterval(() => this.update(), this.frameLength);\n      }\n\n      setInterval(() => this.recordFPS(), 1000);\n    });\n  }\n\n  // Make sure WebGPU is supported, set up the device and the canvas\n  async init(canvas: HTMLCanvasElement | null) {\n    if (!navigator.gpu) {\n      document.getElementById('no-web-gpu')?.classList.add('visible');\n      throw Error('WebGPU not supported');\n    }\n\n    const adapter = await navigator.gpu.requestAdapter();\n\n    if (!adapter) {\n      document.getElementById('no-adapter')?.classList.add('visible');\n      throw Error(\"Couldn't request WebGPU adapter\");\n    }\n\n    const device = await adapter.requestDevice();\n    if (!device) {\n      document.getElementById('no-device')?.classList.add('visible');\n      throw Error('Couldn’t request WebGPU logical device.');\n    }\n\n    this.device = device;\n\n    this._context = canvas?.getContext('webgpu');\n\n    this.canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n    this._context?.configure({ device: this.device, format: this.canvasFormat });\n  }\n\n  get context() {\n    if (!this._context) {\n      document.getElementById('no-canvas')?.classList.add('visible');\n      throw Error(\"Couldn't get canvas context\");\n    }\n\n    return this._context;\n  }\n\n  recordFPS() {\n    const fpsElement = document.getElementById('fps');\n\n    if (!fpsElement || this.avgDeltaT <= 0) return;\n\n    fpsElement.textContent = `${Math.floor(1000 / this.avgDeltaT)} FPS`;\n  }\n\n  /** Put one-time stuff here. Access this.context and this.device */\n  abstract setup(): void;\n\n  /** Put render step here. This will be run every 200ms */\n  abstract update(deltaT?: number): void;\n}\n","export const pointOnCircle = (radius: number, angle: number) => {\n  const x = radius * Math.cos(angle);\n  const y = radius * Math.sin(angle);\n\n  return { x, y };\n};\n\nexport const randomVector = (radius: number) => {\n  const r = Math.sqrt(Math.random()) * radius;\n  const angle = Math.random() * 2 * Math.PI;\n  return pointOnCircle(r, angle);\n};\n"],"names":[],"version":3,"file":"index.3e9ac906.js.map"}