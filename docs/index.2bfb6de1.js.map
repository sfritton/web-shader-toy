{"mappings":"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","sources":["src/scripts/index.ts","src/scripts/GameOfLife.ts","src/scripts/Shader.ts"],"sourcesContent":["import { GameOfLifeShader } from './GameOfLife';\n\nconst canvas = document.querySelector<HTMLCanvasElement>('canvas');\n\nnew GameOfLifeShader(canvas);\n","import { Shader } from './Shader';\n\n/** Both height and width */\nconst GRID_SIZE = 32;\nlet step = 0; // Track how many simulation steps have been run\nconst WORKGROUP_SIZE = 8;\nconst VERTICES = new Float32Array([\n  // Triangle 1 [ x,y, x,y, ...]\n  -0.8, -0.8, 0.8, -0.8, 0.8, 0.8,\n  // Triangle 2 [ x,y, x,y, ...]\n  -0.8, -0.8, 0.8, 0.8, -0.8, 0.8,\n]);\n\nexport class GameOfLifeShader extends Shader {\n  bindGroups!: GPUBindGroup[];\n  cellPipeline!: GPURenderPipeline;\n  simulationPipeline!: GPUComputePipeline;\n  vertexBuffer!: GPUBuffer;\n\n  setup() {\n    this.vertexBuffer = this.device.createBuffer({\n      label: 'Cell Vertices',\n      size: VERTICES.byteLength,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    });\n\n    this.device.queue.writeBuffer(this.vertexBuffer, 0, VERTICES);\n\n    const vertexBufferLayout: GPUVertexBufferLayout = {\n      arrayStride: 8,\n      attributes: [\n        {\n          format: 'float32x2',\n          offset: 0,\n          shaderLocation: 0, // Position, see vertex shader\n        },\n      ],\n    };\n\n    const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);\n    const uniformBuffer = this.device.createBuffer({\n      label: 'Grid Uniforms',\n      size: uniformArray.byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    this.device.queue.writeBuffer(uniformBuffer, 0, uniformArray);\n\n    const cellStateArray = new Uint32Array(GRID_SIZE * GRID_SIZE);\n\n    const cellStateStorage = [\n      this.device.createBuffer({\n        label: 'Cell State A',\n        size: cellStateArray.byteLength,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      }),\n      this.device.createBuffer({\n        label: 'Cell State B',\n        size: cellStateArray.byteLength,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      }),\n    ];\n\n    // Set each cell to a random state\n    for (let i = 0; i < cellStateArray.length; i++) {\n      cellStateArray[i] = Math.random() > 0.6 ? 1 : 0;\n    }\n    this.device.queue.writeBuffer(cellStateStorage[0], 0, cellStateArray);\n\n    const cellShaderModule = this.device.createShaderModule({\n      label: 'Cell shader',\n      code: /*wgsl*/ `\n        struct VertexInput {\n          @location(0) pos: vec2f,\n          @builtin(instance_index) instance: u32,\n        };\n\n        struct VertexOutput {\n          @builtin(position) pos: vec4f,\n          @location(0) cell: vec2f,\n        };\n\n        @group(0) @binding(0) var<uniform> grid: vec2f;\n        @group(0) @binding(1) var<storage> cellState: array<u32>;\n\n        @vertex\n        fn vertexMain(input: VertexInput) -> VertexOutput {\n          // Compute cell coordinates from index\n          let i = f32(input.instance);\n          let cell = vec2f(i % grid.x, floor(i / grid.x));\n          let state = f32(cellState[input.instance]);\n\n          // Determine cell position\n          let cellOffset = cell / grid * 2;\n          let gridPos = (input.pos*state + 1) / grid - 1 + cellOffset;\n\n          var output: VertexOutput;\n          output.pos = vec4f(gridPos, 0, 1);\n          output.cell = cell / grid;\n\n          return output;\n        }\n\n        @fragment\n        fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n          return vec4f(input.cell, 1 - input.cell.x, 1); // (Red, Green, Blue, Alpha)\n        }\n      `,\n    });\n\n    const simulationShaderModule = this.device.createShaderModule({\n      label: 'Game of Life simulation shader',\n      code: /* wgsl */ `\n        @group(0) @binding(0) var<uniform> grid: vec2f; // New line\n\n        @group(0) @binding(1) var<storage> cellStateIn: array<u32>;\n        @group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;\n\n        fn cellIndex(cell: vec2u) -> u32 {\n          return (cell.y % u32(grid.y)) * u32(grid.x) + (cell.x % u32(grid.x));\n        }\n\n        fn cellActive(x: u32, y: u32) -> u32 {\n          return cellStateIn[cellIndex(vec2(x, y))];\n        }\n\n        @compute\n        @workgroup_size(${WORKGROUP_SIZE}, ${WORKGROUP_SIZE})\n        fn computeMain(@builtin(global_invocation_id) cell: vec3u) {\n          let activeNeighbors = cellActive(cell.x+1, cell.y+1) +\n                                cellActive(cell.x+1, cell.y) +\n                                cellActive(cell.x+1, cell.y-1) +\n                                cellActive(cell.x, cell.y-1) +\n                                cellActive(cell.x-1, cell.y-1) +\n                                cellActive(cell.x-1, cell.y) +\n                                cellActive(cell.x-1, cell.y+1) +\n                                cellActive(cell.x, cell.y+1);\n\n          let i = cellIndex(cell.xy);\n\n          // Conway's game of life rules:\n          switch activeNeighbors {\n            case 2: { // Active cells with 2 neighbors stay active.\n              cellStateOut[i] = cellStateIn[i];\n            }\n            case 3: { // Cells with 3 neighbors become or stay active.\n              cellStateOut[i] = 1;\n            }\n            default: { // Cells with < 2 or > 3 neighbors become inactive.\n              cellStateOut[i] = 0;\n            }\n          }\n        }\n      `,\n    });\n\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'Cell Bind Group Layout',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\n          buffer: {}, // Grid uniform buffer\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' }, // Cell state input buffer\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' }, // Cell state output buffer\n        },\n      ],\n    });\n\n    this.bindGroups = [\n      this.device.createBindGroup({\n        label: 'Cell renderer bind group A',\n        layout: bindGroupLayout,\n        entries: [\n          {\n            binding: 0,\n            resource: { buffer: uniformBuffer },\n          },\n          {\n            binding: 1,\n            resource: { buffer: cellStateStorage[0] },\n          },\n          {\n            binding: 2,\n            resource: { buffer: cellStateStorage[1] },\n          },\n        ],\n      }),\n      this.device.createBindGroup({\n        label: 'Cell renderer bind group B',\n        layout: bindGroupLayout,\n        entries: [\n          {\n            binding: 0,\n            resource: { buffer: uniformBuffer },\n          },\n          {\n            binding: 1,\n            resource: { buffer: cellStateStorage[1] },\n          },\n          {\n            binding: 2,\n            resource: { buffer: cellStateStorage[0] },\n          },\n        ],\n      }),\n    ];\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      label: 'Cell Pipeline Layout',\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    this.cellPipeline = this.device.createRenderPipeline({\n      label: 'Cell pipeline',\n      layout: pipelineLayout,\n      vertex: {\n        module: cellShaderModule,\n        entryPoint: 'vertexMain',\n        buffers: [vertexBufferLayout],\n      },\n      fragment: {\n        module: cellShaderModule,\n        entryPoint: 'fragmentMain',\n        targets: [{ format: this.canvasFormat }],\n      },\n    });\n\n    this.simulationPipeline = this.device.createComputePipeline({\n      label: 'Simulation pipeline',\n      layout: pipelineLayout,\n      compute: {\n        module: simulationShaderModule,\n        entryPoint: 'computeMain',\n      },\n    });\n  }\n\n  update() {\n    const encoder = this.device.createCommandEncoder();\n\n    // Start a compute pass\n    const computePass = encoder.beginComputePass();\n\n    computePass.setPipeline(this.simulationPipeline);\n    computePass.setBindGroup(0, this.bindGroups[step % 2]);\n\n    const workgroupCount = Math.ceil(GRID_SIZE / WORKGROUP_SIZE);\n    computePass.dispatchWorkgroups(workgroupCount, workgroupCount);\n\n    computePass.end();\n\n    step++;\n\n    // Start a render pass\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: this.context.getCurrentTexture().createView(),\n          loadOp: 'clear',\n          clearValue: { r: 0, g: 0, b: 0.4, a: 1 },\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    // Draw the grid\n    pass.setPipeline(this.cellPipeline);\n    pass.setVertexBuffer(0, this.vertexBuffer);\n    pass.setBindGroup(0, this.bindGroups[step % 2]);\n    pass.draw(VERTICES.length / 2, GRID_SIZE * GRID_SIZE);\n\n    pass.end();\n\n    // Finish the command buffer and immediately submit it.\n    this.device.queue.submit([encoder.finish()]);\n  }\n}\n","export abstract class Shader {\n  private _context: GPUCanvasContext | null = null;\n  device!: GPUDevice;\n  canvasFormat!: GPUTextureFormat;\n  updateInterval: number = 200;\n\n  constructor(canvas: HTMLCanvasElement | null) {\n    this.init(canvas).then(() => {\n      this.setup();\n      setInterval(() => this.update(), this.updateInterval);\n    });\n  }\n\n  // Make sure WebGPU is supported, set up the device and the canvas\n  async init(canvas: HTMLCanvasElement | null) {\n    if (!navigator.gpu) throw Error('WebGPU not supported');\n\n    const adapter = await navigator.gpu.requestAdapter();\n\n    if (!adapter) throw Error(\"Couldn't request WebGPU adapter\");\n    if (!canvas) throw Error(\"Couldn't find the canvas\");\n\n    this.device = await adapter.requestDevice();\n    this._context = canvas.getContext('webgpu');\n\n    this.canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n    this._context?.configure({ device: this.device, format: this.canvasFormat });\n  }\n\n  get context() {\n    if (!this._context) throw Error(\"Couldn't get canvas context\");\n\n    return this._context;\n  }\n\n  /** Put one-time stuff here. Access this.context and this.device */\n  abstract setup(): void;\n\n  /** Put render step here. This will be run every 200ms */\n  abstract update(): void;\n}\n"],"names":[],"version":3,"file":"index.2bfb6de1.js.map"}