{"mappings":"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","sources":["src/scripts/index.ts","src/scripts/FlameShader/index.ts","src/scripts/Shader.ts","src/scripts/FlameShader/util.ts","src/scripts/FlameShader/constants.ts","src/scripts/FlameShader/shaders/index.ts","node_modules/@parcel/runtime-js/lib/bundles/runtime-c35fcd6eb44ac9f3.js","node_modules/@parcel/runtime-js/lib/bundles/runtime-c1d93a9d36258b7e.js","node_modules/@parcel/runtime-js/lib/bundles/runtime-4fa4a55f9976aba1.js"],"sourcesContent":["import { FlameShader } from './FlameShader';\n\nconst canvas = document.querySelector<HTMLCanvasElement>('canvas');\n\nnew FlameShader(canvas);\n","import { Shader } from '../Shader';\nimport { pointOnCircle, randomVector } from './util';\nimport {\n  WORKGROUP_SIZE,\n  PARTICLE_COUNT,\n  PARTICLE_INTERVAL,\n  ORIGIN_RADIUS,\n  ORIGIN_Y,\n} from './constants';\n\nimport { computeParticlesShader, renderBackgroundShader, renderParticlesShader } from './shaders';\n\nconst TRIANGLE_COUNT = 16;\nconst THETA = (2 * Math.PI) / TRIANGLE_COUNT;\nconst VERTICES = new Float32Array(TRIANGLE_COUNT * 6); // 6 for the x,y coordinates of the three points on the triangle\n\nfor (let triangleIndex = 0; triangleIndex < TRIANGLE_COUNT; triangleIndex++) {\n  const i = triangleIndex * 6;\n  const point1 = pointOnCircle(1, triangleIndex * THETA);\n  const point2 = pointOnCircle(1, (triangleIndex + 1) * THETA);\n\n  VERTICES[i] = 0;\n  VERTICES[i + 1] = 0;\n\n  VERTICES[i + 2] = point1.x;\n  VERTICES[i + 3] = point1.y;\n\n  VERTICES[i + 4] = point2.x;\n  VERTICES[i + 5] = point2.y;\n}\n\nexport class FlameShader extends Shader {\n  vertexBuffer!: GPUBuffer;\n  renderPipeline!: GPURenderPipeline;\n  backgroundPipeline!: GPURenderPipeline;\n  computePipeline!: GPUComputePipeline;\n  bindGroups!: GPUBindGroup[];\n  frameLength = 0;\n\n  setup() {\n    const particleCounter = document.getElementById('particle-count');\n    if (particleCounter) {\n      particleCounter.textContent = `${Math.floor(PARTICLE_COUNT / 1000)},000`;\n    }\n    /*\n    ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n    │ PARTICLE SHAPE                  │\n    ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n    */\n    this.vertexBuffer = this.device.createBuffer({\n      label: 'Particle Vertices',\n      size: VERTICES.byteLength,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    });\n\n    this.device.queue.writeBuffer(this.vertexBuffer, 0, VERTICES);\n\n    const vertexBufferLayout: GPUVertexBufferLayout = {\n      arrayStride: 8,\n      attributes: [\n        {\n          format: 'float32x2',\n          offset: 0,\n          shaderLocation: 0, // Position, see vertex shader\n        },\n      ],\n    };\n\n    /*\n    ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n    │ PARTICLE DATA                   │\n    ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n    */\n\n    /**\n     * Particle state, stored as [\n     *   position.x,\n     *   position.y,\n     *   velocity.x,\n     *   velocity.y,\n     *   lifespan\n     * ]\n     *\n     */\n    const particleStates = new Float32Array(PARTICLE_COUNT * PARTICLE_INTERVAL);\n\n    for (let i = 0; i < particleStates.length; i += PARTICLE_INTERVAL) {\n      const position = randomVector(ORIGIN_RADIUS);\n      const velocity = randomVector(ORIGIN_RADIUS);\n\n      particleStates[i] = position.x;\n      particleStates[i + 1] = position.y + ORIGIN_Y;\n      particleStates[i + 2] = velocity.x;\n      particleStates[i + 3] = velocity.y;\n      particleStates[i + 4] = Math.random();\n    }\n\n    const particleStatesStorage = [\n      this.device.createBuffer({\n        label: 'Particle State A',\n        size: particleStates.byteLength,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      }),\n      this.device.createBuffer({\n        label: 'Particle State B',\n        size: particleStates.byteLength,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      }),\n    ];\n\n    this.device.queue.writeBuffer(particleStatesStorage[0], 0, particleStates);\n\n    const initialStatesStorage = this.device.createBuffer({\n      label: 'Initial Particle State',\n      size: particleStates.byteLength,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n\n    this.device.queue.writeBuffer(initialStatesStorage, 0, particleStates);\n\n    /*\n    ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n    │ BIND GROUPS & LAYOUTS           │\n    ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n    */\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      label: 'Particle Bind Group Layout',\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' }, // Particle state input buffer\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' }, // Particle state output buffer\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'read-only-storage' }, // Uniform buffer\n        },\n      ],\n    });\n\n    this.bindGroups = [\n      this.device.createBindGroup({\n        label: 'Particle renderer bind group A',\n        layout: bindGroupLayout,\n        entries: [\n          {\n            binding: 0,\n            resource: { buffer: particleStatesStorage[0] },\n          },\n          {\n            binding: 1,\n            resource: { buffer: particleStatesStorage[1] },\n          },\n          {\n            binding: 2,\n            resource: { buffer: initialStatesStorage },\n          },\n        ],\n      }),\n      this.device.createBindGroup({\n        label: 'Particle renderer bind group B',\n        layout: bindGroupLayout,\n        entries: [\n          {\n            binding: 0,\n            resource: { buffer: particleStatesStorage[1] },\n          },\n          {\n            binding: 1,\n            resource: { buffer: particleStatesStorage[0] },\n          },\n          {\n            binding: 2,\n            resource: { buffer: initialStatesStorage },\n          },\n        ],\n      }),\n    ];\n\n    const pipelineLayout = this.device.createPipelineLayout({\n      label: 'Particle pipeline layout',\n      bindGroupLayouts: [bindGroupLayout],\n    });\n\n    /*\n    ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n    │ COMPUTE PIPELINE                │\n    ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n    */\n    const computeShaderModule = this.device.createShaderModule({\n      label: 'Flame compute shader',\n      code: computeParticlesShader,\n    });\n\n    this.computePipeline = this.device.createComputePipeline({\n      label: 'Flame compute pipeline',\n      layout: pipelineLayout,\n      compute: {\n        module: computeShaderModule,\n        entryPoint: 'computeMain',\n      },\n    });\n\n    /*\n    ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n    │ RENDER PIPELINE                 │\n    ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n    */\n    const renderShaderModule = this.device.createShaderModule({\n      label: 'Flame render shader',\n      code: renderParticlesShader,\n    });\n\n    this.renderPipeline = this.device.createRenderPipeline({\n      label: 'Flame render pipeline',\n      layout: pipelineLayout,\n      vertex: {\n        module: renderShaderModule,\n        entryPoint: 'vertexMain',\n        buffers: [vertexBufferLayout],\n      },\n      fragment: {\n        module: renderShaderModule,\n        entryPoint: 'fragmentMain',\n        targets: [\n          {\n            format: this.canvasFormat,\n            blend: {\n              color: {\n                srcFactor: 'one',\n                dstFactor: 'one-minus-src-alpha',\n              },\n              alpha: {\n                srcFactor: 'one',\n                dstFactor: 'one-minus-src-alpha',\n              },\n            },\n          },\n        ],\n      },\n    });\n\n    const backgroundShaderModule = this.device.createShaderModule({\n      label: 'Background render shader',\n      code: renderBackgroundShader,\n    });\n\n    this.backgroundPipeline = this.device.createRenderPipeline({\n      label: 'Background render pipeline',\n      layout: 'auto',\n      vertex: {\n        module: backgroundShaderModule,\n        entryPoint: 'vertexMain',\n        buffers: [vertexBufferLayout],\n      },\n      fragment: {\n        module: backgroundShaderModule,\n        entryPoint: 'fragmentMain',\n        targets: [\n          {\n            format: this.canvasFormat,\n            blend: {\n              color: {\n                srcFactor: 'one',\n                dstFactor: 'one-minus-src-alpha',\n              },\n              alpha: {\n                srcFactor: 'one',\n                dstFactor: 'one-minus-src-alpha',\n              },\n            },\n          },\n        ],\n      },\n    });\n  }\n\n  updateCompute(encoder: GPUCommandEncoder) {\n    const computePass = encoder.beginComputePass();\n\n    computePass.setPipeline(this.computePipeline);\n    computePass.setBindGroup(0, this.bindGroups[this.step % 2]);\n\n    const workgroupCount = Math.ceil(PARTICLE_COUNT / WORKGROUP_SIZE);\n    computePass.dispatchWorkgroups(workgroupCount, workgroupCount);\n\n    computePass.end();\n  }\n\n  updateRender(encoder: GPUCommandEncoder) {\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: this.context.getCurrentTexture().createView(),\n          loadOp: 'clear',\n          clearValue: { r: 0, g: 0, b: 0.15, a: 1 },\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    pass.setPipeline(this.backgroundPipeline);\n    pass.setVertexBuffer(0, this.vertexBuffer);\n    pass.draw(VERTICES.length / 2);\n\n    pass.setPipeline(this.renderPipeline);\n    pass.setVertexBuffer(0, this.vertexBuffer);\n    pass.setBindGroup(0, this.bindGroups[this.step % 2]);\n    pass.draw(VERTICES.length / 2, PARTICLE_COUNT);\n\n    pass.end();\n  }\n}\n","export abstract class Shader {\n  private _context: GPUCanvasContext | null | undefined = undefined;\n  private _canvas: HTMLCanvasElement | null | undefined = undefined;\n  device!: GPUDevice;\n  canvasFormat!: GPUTextureFormat;\n  /** Milliseconds between frames. Set to 0 for maximum FPS. */\n  frameLength: number = 200;\n  prevMS: number | undefined = undefined;\n  avgDeltaT = 0;\n  /** The current step of the animation. */\n  step = 0;\n\n  constructor(canvas: HTMLCanvasElement | null) {\n    this.init(canvas).then(() => {\n      this.setup();\n      if (this.frameLength === 0) {\n        const step = (currMS: number) => {\n          const deltaT = this.calculateDeltaT(currMS);\n\n          requestAnimationFrame(step);\n          this.update(deltaT);\n        };\n\n        requestAnimationFrame(step);\n      } else {\n        setInterval(() => this.update(), this.frameLength);\n      }\n\n      setInterval(() => this.recordFPS(), 1000);\n    });\n  }\n\n  calculateDeltaT(currMS: number) {\n    if (this.prevMS === undefined) this.prevMS = currMS;\n\n    const deltaT = currMS - this.prevMS;\n\n    if (this.avgDeltaT === 0) {\n      this.avgDeltaT = deltaT;\n      // Don't update the average if the current frame is a 500% increase\n      // This is likely due to an inactive browser tab\n    } else if (deltaT / this.avgDeltaT < 5) {\n      this.avgDeltaT = (this.avgDeltaT * this.step + deltaT) / (this.step + 1);\n    }\n\n    this.prevMS = currMS;\n\n    return deltaT;\n  }\n\n  // Make sure WebGPU is supported, set up the device and the canvas\n  async init(canvas: HTMLCanvasElement | null) {\n    if (!navigator.gpu) {\n      document.getElementById('no-web-gpu')?.classList.add('visible');\n      throw Error('WebGPU not supported');\n    }\n\n    const adapter = await navigator.gpu.requestAdapter();\n\n    if (!adapter) {\n      document.getElementById('no-adapter')?.classList.add('visible');\n      throw Error(\"Couldn't request WebGPU adapter\");\n    }\n\n    const device = await adapter.requestDevice();\n    if (!device) {\n      document.getElementById('no-device')?.classList.add('visible');\n      throw Error('Couldn’t request WebGPU logical device.');\n    }\n\n    this.device = device;\n\n    this._canvas = canvas;\n    this._context = this._canvas?.getContext('webgpu');\n\n    this.canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n    this._context?.configure({ device: this.device, format: this.canvasFormat });\n  }\n\n  get context() {\n    if (!this._context) {\n      document.getElementById('no-canvas')?.classList.add('visible');\n      throw Error(\"Couldn't get canvas context\");\n    }\n\n    return this._context;\n  }\n\n  get canvas() {\n    if (!this._canvas) {\n      document.getElementById('no-canvas')?.classList.add('visible');\n      throw Error(\"Couldn't get canvas element\");\n    }\n\n    return this._canvas;\n  }\n\n  recordFPS() {\n    const params = new URLSearchParams(window.location.search);\n    const shouldShowStats = params.has('stats', 'true');\n    const fpsElement = document.getElementById('fps');\n\n    if (!fpsElement || this.avgDeltaT <= 0 || !shouldShowStats) return;\n\n    fpsElement.textContent = `${Math.floor(1000 / this.avgDeltaT)} FPS`;\n  }\n\n  /** Put one-time stuff here. Access this.context and this.device */\n  abstract setup(): void;\n\n  update(deltaT?: number) {\n    const encoder = this.device.createCommandEncoder();\n\n    this.updateCompute(encoder, deltaT);\n    this.step++;\n    this.updateRender(encoder, deltaT);\n\n    // Finish the command buffer and immediately submit it.\n    this.device.queue.submit([encoder.finish()]);\n  }\n\n  /** Put compute step here. This will be run every frame. */\n  abstract updateCompute(encoder: GPUCommandEncoder, deltaT?: number): void;\n\n  /** Put render step here. This will be run every frame, following `updateCompute`. */\n  abstract updateRender(encoder: GPUCommandEncoder, deltaT?: number): void;\n}\n","export const pointOnCircle = (radius: number, angle: number) => {\n  const x = radius * Math.cos(angle);\n  const y = radius * Math.sin(angle);\n\n  return { x, y };\n};\n\nexport const randomVector = (radius: number) => {\n  const r = Math.sqrt(Math.random()) * radius;\n  const angle = Math.random() * 2 * Math.PI;\n  return pointOnCircle(r, angle);\n};\n","export const WORKGROUP_SIZE = 64;\nexport const PARTICLE_SIZE = 0.1;\nexport const PARTICLE_COUNT = WORKGROUP_SIZE * 128;\nexport const SPEED = 0.004;\nexport const GRAVITY = 0.005;\nexport const PARTICLE_INTERVAL = 5;\nexport const DECAY_RATE = 0.004;\nexport const ORIGIN_RADIUS = 0.2;\nexport const ORIGIN_Y = -0.4;\n","import * as constants from '../constants';\n// @ts-expect-error\nimport renderParticles from 'bundle-text:./renderParticles.wgsl';\n// @ts-expect-error\nimport computeParticles from 'bundle-text:./computeParticles.wgsl';\n// @ts-expect-error\nimport renderBackground from 'bundle-text:./renderBackground.wgsl';\n\nconst withConstants = (shader: string) =>\n  shader.replace(\n    /\\$\\{([A-Z_]+)\\}/g,\n    (_, variableName: string) => (constants as Record<string, any>)[variableName],\n  );\n\nexport const renderParticlesShader = withConstants(renderParticles);\nexport const computeParticlesShader = withConstants(computeParticles);\nexport const renderBackgroundShader = withConstants(renderBackground);\n","module.exports = \"0eedf11aa7b2b235\";","module.exports = \"e37a7cae3c2ad91c\";","module.exports = \"a5afadeab2ef9414\";"],"names":[],"version":3,"file":"index.0931c434.js.map"}