{"mappings":"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","sources":["src/scripts/index.ts"],"sourcesContent":["/// <reference types=\"@webgpu/types\" />\n\n/** Both height and width */\nconst GRID_SIZE = 32;\nconst UPDATE_INTERVAL = 200; // Update every 200ms (5 times/sec)\nlet step = 0; // Track how many simulation steps have been run\nconst WORKGROUP_SIZE = 8;\n\nasync function init() {\n  /*\n   ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n   │ 0. CANVAS & DEVICE SETUP        │\n   ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n   */\n  if (!navigator.gpu) throw Error('WebGPU not supported');\n\n  const adapter = await navigator.gpu.requestAdapter();\n\n  if (!adapter) throw Error(\"Couldn't request WebGPU adapter\");\n\n  const canvas = document.querySelector<HTMLCanvasElement>('canvas.cave-generator');\n\n  if (!canvas) throw Error(\"Couldn't find the canvas\");\n\n  const device = await adapter.requestDevice();\n  const context = canvas.getContext('webgpu');\n\n  if (!context) throw Error(\"Couldn't get canvas context\");\n\n  const canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n  context.configure({ device, format: canvasFormat });\n\n  /*\n   ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑\n   │ 1. DRAW A SQUARE                │\n   ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙\n   */\n  const vertices = new Float32Array([\n    // Triangle 1 [ x,y, x,y, ...]\n    -0.8, -0.8, 0.8, -0.8, 0.8, 0.8,\n    // Triangle 2 [ x,y, x,y, ...]\n    -0.8, -0.8, 0.8, 0.8, -0.8, 0.8,\n  ]);\n\n  const vertexBuffer = device.createBuffer({\n    label: 'Cell vertices',\n    size: vertices.byteLength,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n  });\n\n  device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/ 0, vertices);\n\n  const vertexBufferLayout: GPUVertexBufferLayout = {\n    arrayStride: 8,\n    attributes: [\n      {\n        format: 'float32x2',\n        offset: 0,\n        shaderLocation: 0, // Position, see vertex shader\n      },\n    ],\n  };\n\n  const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);\n  const uniformBuffer = device.createBuffer({\n    label: 'Grid Uniforms',\n    size: uniformArray.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  device.queue.writeBuffer(uniformBuffer, 0, uniformArray);\n\n  const cellStateArray = new Uint32Array(GRID_SIZE * GRID_SIZE);\n\n  const cellStateStorage = [\n    device.createBuffer({\n      label: 'Cell State A',\n      size: cellStateArray.byteLength,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    }),\n    device.createBuffer({\n      label: 'Cell State B',\n      size: cellStateArray.byteLength,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    }),\n  ];\n\n  // Set each cell to a random state\n  for (let i = 0; i < cellStateArray.length; i++) {\n    cellStateArray[i] = Math.random() > 0.6 ? 1 : 0;\n  }\n  device.queue.writeBuffer(cellStateStorage[0], 0, cellStateArray);\n\n  const cellShaderModule = device.createShaderModule({\n    label: 'Cell shader',\n    code: /*wgsl*/ `\n      struct VertexInput {\n        @location(0) pos: vec2f,\n        @builtin(instance_index) instance: u32,\n      };\n\n      struct VertexOutput {\n        @builtin(position) pos: vec4f,\n        @location(0) cell: vec2f,\n      };\n\n      @group(0) @binding(0) var<uniform> grid: vec2f;\n      @group(0) @binding(1) var<storage> cellState: array<u32>;\n\n      @vertex\n      fn vertexMain(input: VertexInput) -> VertexOutput {\n        // Compute cell coordinates from index\n        let i = f32(input.instance);\n        let cell = vec2f(i % grid.x, floor(i / grid.x));\n        let state = f32(cellState[input.instance]);\n\n        // Determine cell position\n        let cellOffset = cell / grid * 2;\n        let gridPos = (input.pos*state + 1) / grid - 1 + cellOffset;\n\n        var output: VertexOutput;\n        output.pos = vec4f(gridPos, 0, 1);\n        output.cell = cell / grid;\n\n        return output;\n      }\n\n      @fragment\n      fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n        return vec4f(input.cell, 1 - input.cell.x, 1); // (Red, Green, Blue, Alpha)\n      }\n    `,\n  });\n\n  const simulationShaderModule = device.createShaderModule({\n    label: 'Game of Life simulation shader',\n    code: /* wgsl */ `\n      @group(0) @binding(0) var<uniform> grid: vec2f; // New line\n\n      @group(0) @binding(1) var<storage> cellStateIn: array<u32>;\n      @group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;\n\n      fn cellIndex(cell: vec2u) -> u32 {\n        return (cell.y % u32(grid.y)) * u32(grid.x) + (cell.x % u32(grid.x));\n      }\n\n      fn cellActive(x: u32, y: u32) -> u32 {\n        return cellStateIn[cellIndex(vec2(x, y))];\n      }\n\n      @compute\n      @workgroup_size(${WORKGROUP_SIZE}, ${WORKGROUP_SIZE})\n      fn computeMain(@builtin(global_invocation_id) cell: vec3u) {\n        let activeNeighbors = cellActive(cell.x+1, cell.y+1) +\n                              cellActive(cell.x+1, cell.y) +\n                              cellActive(cell.x+1, cell.y-1) +\n                              cellActive(cell.x, cell.y-1) +\n                              cellActive(cell.x-1, cell.y-1) +\n                              cellActive(cell.x-1, cell.y) +\n                              cellActive(cell.x-1, cell.y+1) +\n                              cellActive(cell.x, cell.y+1);\n\n        let i = cellIndex(cell.xy);\n\n        // Conway's game of life rules:\n        switch activeNeighbors {\n          case 2: { // Active cells with 2 neighbors stay active.\n            cellStateOut[i] = cellStateIn[i];\n          }\n          case 3: { // Cells with 3 neighbors become or stay active.\n            cellStateOut[i] = 1;\n          }\n          default: { // Cells with < 2 or > 3 neighbors become inactive.\n            cellStateOut[i] = 0;\n          }\n        }\n      }\n    `,\n  });\n\n  const bindGruopLayout = device.createBindGroupLayout({\n    label: 'Cell Bind Group Layout',\n    entries: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\n        buffer: {}, // Grid uniform buffer\n      },\n      {\n        binding: 1,\n        visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\n        buffer: { type: 'read-only-storage' }, // Cell state input buffer\n      },\n      {\n        binding: 2,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: { type: 'storage' }, // Cell state output buffer\n      },\n    ],\n  });\n\n  const bindGroups = [\n    device.createBindGroup({\n      label: 'Cell renderer bind group A',\n      layout: bindGruopLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: uniformBuffer },\n        },\n        {\n          binding: 1,\n          resource: { buffer: cellStateStorage[0] },\n        },\n        {\n          binding: 2,\n          resource: { buffer: cellStateStorage[1] },\n        },\n      ],\n    }),\n    device.createBindGroup({\n      label: 'Cell renderer bind group B',\n      layout: bindGruopLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer: uniformBuffer },\n        },\n        {\n          binding: 1,\n          resource: { buffer: cellStateStorage[1] },\n        },\n        {\n          binding: 2,\n          resource: { buffer: cellStateStorage[0] },\n        },\n      ],\n    }),\n  ];\n\n  const pipelineLayout = device.createPipelineLayout({\n    label: 'Cell Pipeline Layout',\n    bindGroupLayouts: [bindGruopLayout],\n  });\n\n  const cellPipeline = device.createRenderPipeline({\n    label: 'Cell pipeline',\n    layout: pipelineLayout,\n    vertex: {\n      module: cellShaderModule,\n      entryPoint: 'vertexMain',\n      buffers: [vertexBufferLayout],\n    },\n    fragment: {\n      module: cellShaderModule,\n      entryPoint: 'fragmentMain',\n      targets: [{ format: canvasFormat }],\n    },\n  });\n\n  const simulationPipeline = device.createComputePipeline({\n    label: 'Simulation pipeline',\n    layout: pipelineLayout,\n    compute: {\n      module: simulationShaderModule,\n      entryPoint: 'computeMain',\n    },\n  });\n\n  function updateGrid() {\n    if (!context) return;\n\n    const encoder = device.createCommandEncoder();\n\n    // Start a compute pass\n    const computePass = encoder.beginComputePass();\n\n    computePass.setPipeline(simulationPipeline);\n    computePass.setBindGroup(0, bindGroups[step % 2]);\n\n    const workgroupCount = Math.ceil(GRID_SIZE / WORKGROUP_SIZE);\n    computePass.dispatchWorkgroups(workgroupCount, workgroupCount);\n\n    computePass.end();\n\n    step++;\n\n    // Start a render pass\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: context.getCurrentTexture().createView(),\n          loadOp: 'clear',\n          clearValue: { r: 0, g: 0, b: 0.4, a: 1 },\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    // Draw the grid\n    pass.setPipeline(cellPipeline);\n    pass.setVertexBuffer(0, vertexBuffer);\n    pass.setBindGroup(0, bindGroups[step % 2]);\n    pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE);\n\n    pass.end();\n\n    // Finish the command buffer and immediately submit it.\n    device.queue.submit([encoder.finish()]);\n  }\n\n  setInterval(updateGrid, UPDATE_INTERVAL);\n}\n\ninit();\n"],"names":[],"version":3,"file":"index.fe710d06.js.map"}